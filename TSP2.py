import itertools as itrimport numpy as npimport mathDis = {}# List of cities and epochscity = ['A','B','C','D','E']epoch = [1,2,3,4,5,6]#dictionary holding the distance between cities.Dis["AB"] = 10Dis["BA"] = 10Dis["AC"] = 20Dis["CA"] = 20Dis["AD"] = 5Dis["DA"] = 5Dis["AE"] = 18Dis["EA"] = 18Dis["BC"] = 15Dis["CB"] = 15Dis["BD"] = 32Dis["DB"] = 32Dis["BE"] = 10Dis["EB"] = 10Dis["CD"] = 25Dis["DC"] = 25Dis["CE"] = 16Dis["EC"] = 16Dis["DE"] = 35Dis["ED"] = 35# a list for creating labels for the Boltzmann machine nodes#by cross product between city name and epochs. we will have total# of 30 nodesBM_node_label = list(itr.product(city,epoch))print('******** the BM_idx details *************')print(BM_node_label)print(len(BM_node_label))# create a list labeling the weights(edges between nodes) by cross #joining BM_node_label above to itself.#a Weight is labeled by the name of the two nodes it is connecting.#there will be 30*30 weights at this point. The 30 self-connecting #weights will be removed later.BM_wt_label = list(itr.product(BM_node_label,BM_node_label))print(len(BM_wt_label))# the following is a dictionary holding the biases associated to each #city.# I will explain how I chose those values in the reportBias = {'A':95,'B':105,'C':113,'D':140,'E':115}#In what follows I set the weight values. I have assigned appropriate #weight values# to enforce the TS constraints.BM_wt = {}for (node1,node2) in BM_wt_label:    if(node1 == node2): # no self connection        pass   	#defining the weight between first epoch node and sixth epoch node.    #the weight is set to zero indicating that we need first and last epoch to be the same.    elif(node1[0] == node2[0] and ((node1[1] ==1 and node2[1] == 6) or (node1[1] ==6 and node2[1] == 1) )):        BM_wt[(node1,node2)] = 0    # below weight definition enforces that the sales man should not travel to same city more than once.    elif(node1[0] == node2[0]):        BM_wt[(node1,node2)] = -150    # Below weight definition enforces that the sales man cannot be in two cities at the same time    elif(node1[1] == node2[1]):        BM_wt[(node1,node2)] = -150    # the following weight defines actual distance between the cities.    else:        BM_wt[(node1,node2)] = -1 * Dis[node1[0]+node2[0]]print('************ weight *********')#print(BM_wt)#intialize temprature to high valueT = 1000.0#So far we are done creating BM. Next, we will start solving the optimization problem.#1. The first step would be assigning initial state to BM nodes. This is done in two steps:# Initialize all state to zeroBM ={}for n in BM_node_label:    BM[n] =0#For each epoch 1 to 5, pick one of the node and set it to 1.#This will create a valid initial tour.for i in range(1,6):    rnd = np.random.randint(1,6) # generate a rondom number from 1 to 5    #identifyinh which city to turn on based on the random number    e = 'A' if rnd == 1 else 'B' if rnd == 2 else 'C' if rnd == 3 else 'D' if rnd == 4 else 'E'    #the below routine is used to enforce that the city to set in epoch 6    #should be the same as the city set on in the first epoch    if i == 1:        epoch1 = e    # turn on the randomly selected node of current epoch    BM[(e,i)] = 1#The following makes sure that the sales man returns to the same city he starts.# This can be considered as hard constraint of the optimization problem unlike others constraints#which are implemented softly through picking right value of weight.BM[epoch1,6] = 1       print('************Initialized BM *************')tour = ['%s%d' %(x,y) for (x,y) in sorted(BM,key = lambda x: x[1]) if BM[(x,y)] == 1]print('randomly picked initial tour %s ' % tour)# Once the BM is initialized, now we are ready to start the annealing process# Below is a function that compute the probability of acceptance for a node# Input parameters:# node: is the node selected for update# BM_wt: is the weight # T: is the temperaturedef acceptance(node,BM_wt,T):    #variable for holding activity value    s = 0    #compute the activity value of the node    for (n1,n2) in BM_wt:        if(n2 == node ):            s = s+BM_wt[(n1,n2)]*BM[n1]    # compute the change in Consensus based on activity value    # and bias    deltaC  = (1 - 2*BM[node]) *(s + Bias[node[0]])    #compute the probability of acceptance. If deltaC/T is too big,    # which happens when T->0, there will be OverflowError hence    #set p = 1 when (deltaC/T) -> very large positive number    try:        p = 1/(1 + math.exp(-1.0*deltaC/T))    except OverflowError:        p =1    return p# Following is the routine that does the annealing process. It will#randomly pick a node and do the probabilistic update# again, we only consider the first 5 epochs and enforce the sixth epoch# to agree to the first epoch.# get the list of nodes corresponding to epochs 1 to 5.# there will be 25 nodes.epoch1_5 = [n for n in BM_node_label if n[1] !=6]# Do the annealing. For each temperature, carry out the node update 10,000 times# then reduce T by 5% and repeat the process.while (T > 0.5):    for itr in range(10000):        # randomly pick a node        idx = np.random.randint(len(epoch1_5))        node = epoch1_5[idx]        #compute the acceptance probability        p = acceptance(node,BM_wt,T)        # do probabilistic update        if(np.random.random() <= p ):            BM[node] = 1 - BM[node]            #Hard constraint: sales man should return to the same city.            if(node[1] == 1):                BM[(node[0], 6)] = BM[node] # forcing 6th epoch as the first        else:            pass    # printing the final tour and tout length at each temprature    print('*************** after 10000 random updates at %f temp ************' % T)    tour = ['%s%d' %(x,y) for (x,y) in sorted(BM,key = lambda x: x[1]) if BM[(x,y)] == 1]    path =[x for (x,y) in sorted(BM,key = lambda x: x[1]) if BM[(x,y)] == 1]    r = [path[i] + path[i+1] for i in range(len(path)) if i != len(path)-1]    distance = 0    for pr in r:        distance += Dis.get(pr,0)    print('%s : %d' %(str(tour), distance))    T = 0.95*T